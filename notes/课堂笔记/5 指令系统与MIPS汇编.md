# 指令系统概述

## 指令集系统架构（ISA）种类

Register-Memory式

- 多种指令**可以访问内存**
  - mips不可以直接访问内存，只能通过load-store进行访问，这是主要区别所在

- 存在寄存器操作数和内存操作数直接运行的指令

Load-Store式

- 只有load和store指令可以访问内存
- 运算指令操作数全为寄存器操作数

Load-Store是ISA的一种趋势

## 指令格式

机器指令：计算机硬件可以执行的，表示一种基本操作的二进制代码

操作码（指明操作数的位置）+操作数（实际上是地址，或者是数据本身，如I型指令）

## 寻址方式

形式地址：指令中直接给出的地址编码

有效地址：根据形式地址和寻址方式计算出的操作数在内存中的地址

寻址方式：根据形式地址计算到操作数的有效地址的方式

- 立即寻址：操作数在指令处给出，地址处是立即数

  - 立即数存储在指令中，不额外存储在别的地方

- 寄存器直接寻址：值存储在寄存器中，地址为相应寄存器的编号

- 寄存器间接寻址：**值存储在存储器中**，地址是寄存器编号，寄存器中存储了所需地址

  - MIPS无寄存器间接寻址

- 基址地址/变址寻址：按基址+偏移量寻址
  - 基址寻址的作用：**较短的形式地址长度可以实现较大的存储空间的寻址**。

  - 有的系统中，变址寻址完成后，变址寄存器的内容将自动进行调整。

    ![image-20231016144442917](https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202310161444999.png)

- 相对寻址：以程序计数器PC为基址寄存器
  - `beq $t1,$t2,100`就是相对寻址，以PC为基址寄存器

- 堆栈地址
  - `$sp`是一个特殊的寄存器，存放了栈顶指针指向的位置

  - ```mipsasm
    .macro inStack(%dst)
    	sw %dst,0($sp)
    	subi $sp,$sp,4
    .end_macro
    
    .macro outStack(%dst)
    	addi $sp,$sp,4
    	lw %dst,0($sp)
    .end_macro	
    ```

### 寻址中的有关缩写

![image-20231016143714594](https://pigkiller-011955-1319328397.cos.ap-beijing.myqcloud.com/img/202310161437685.png)

# 典型指令系统

## 8086/8088指令系统

可以访问的主存物理地址为20位（1M），超多的存储空间通过其他方式访问

机器字长16位，所有寄存器16位，数据总线16位

.exe的存储结构：代码段+数据端+堆栈段

## Mips指令

### 简介

32位指令，32位虚拟地址空间

- 32个32位通用寄存器
- 32个32位浮点数寄存器
- HI、LO、PC：`mfhi,mthi,mflo,mtlo`来实现HI，LO寄存器和通用寄存器之间的数据交换
- 一个字为32位

 R、I、J三种指令的区别的本质是在于寻址方式的区别

- R：register，直接访问寄存器
- I：immi，直接为立即数或立即数偏移量+基地址
- J：jump

## CISC和RISC

两种不同的思想，两种相反的方向：谁离软件更近

增强指令功能：CISC

- 格式复杂，寻址方式复杂
- 把一些有软件实现的常用功能改用硬件的指令系统实现

简化指令功能：RISC

# Mips汇编语言

具体见实验课笔记，此处仅强调一部分

## 指令的形式

```mipsasm
#R:register
opcode(6) rs(5) rt(5) rd(5) shamt(5) funct(6)

#I:immediate
opcode(5) rs(5) rt(5) immediate(16)

#J:jump
opcode(6) targetaddress(26)
```

opcode&funct：一同决定指令类型

- opcode为0时为R型指令
- 在I型指令中，因为没有funct字段，opcode唯一指定一条指令

rs：source register，通常存放第一个操作数的寄存器。

rt：target register，通常表示第二个操作数的寄存器，如果仅有一个寄存器吗，则作为结果存放寄存器

rd：destination register，，通常指定存放计算结果的寄存器

shamt：存储执行计算式需要移位的位数

## 指令的跳转

beq指令和bne指令是I型指令，立即数只有16bits，而PC有32bit的指向内存的指针，立即数无法表示出完整的内存地址

**使用PC相对寻址方案**：

- PC中存储的是下一条指令的地址，跳转的指令的偏移量是相对**下一条指令的偏移量**
- 下一行指令偏移为0，下两行偏移为1……
- 标签不被PC存储，不占单独的地址

## 伪指令

汇编程序利用标签来构建符号表，即伪指令声明的变量被存储在了存储器中，被指定了标签

数据伪指令：

- `.BYTE`伪指令，以**8位字节**存储数值表
- `.HALF`伪指令，以**16位（半字长）**存储数值表
- `.WORD`伪指令，以32位（一个字长）存储数值表
- `.WORD w:n`伪指令，将32位数值w存入n个边界对齐的连续的字中
- `.FLOAT`伪指令，以单精度浮点数存储数值表
- `.DOUBLE`伪指令，以双精度浮点数存储数值表

字符串伪指令：

- `.ASCII`伪指令，为一个ASCII字符串分配字节序列
- `.ASCIIZ`伪指令，与.ASCII伪指令类似,但字符串以NULL结尾
- `.SPACE n`伪指令，为数据段中n个未初始化的**字节**分配空间
- 字符串中的特殊字符（按照C语言的约定），“新行:nTabt，引用:















