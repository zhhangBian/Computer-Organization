## 我的认识

对于测试，我的一个思考就是在不考虑溢出信号输出之前，频繁地测试大数据、边界值的意义其实并不大。硬件和之前编写的C程序的区别就在于，我们所搭建的CPU的核心功能是翻译指令，只要做到能够翻译对，那么在数据通路正确的情况下，对于边界值的情况没有理由翻译不对。

最多需要考虑位宽究竟设置对了没有——因为对于`verilog`这样的硬件描述语言来讲，溢出、数据错误往往都是来自于位宽没有对准、位宽错误，数据的范围就是位宽的范围。



对于我们目前的CPU，所做的其实就是数据通路+控制信号，控制信号的测试决定了指令能否被识别出正确的功能，数据通路则决定了



基于这样的认识，测试所需要的事其实就是两件：数据有没有放对寄存器、内存，数据的位宽对不对。

对于放对寄存器，这个很容易测，将数据在每个寄存器都放一遍，能放对就是得到了正确的结果。而去对于我所设计的CPU，不同质量的区别在于控制信号——都有着一样的数据通路，那么放对位置其实不用测很多次，R指令、I指令都各测一条实际上就可以达到测试效果。

对于位宽对不对的问题，只需要测试`fff+fff`这种大位宽、有进位数据即可，达到了测试位宽+正确性的效果。

## 基于我的认识构建的测试数据

总结一下前文我的认识，那么这样的测试可以分为两步：测试数据通路+测试指令能否正确翻译。

测试数据通路要充分考虑到位宽、转发阻塞等情况，这是硬件本身的搭建是否正确。对于测试指令翻译的正确性，则就是测试相应的控制信号是否正确，能够执行正确的读写操作，按理说一条指令只要测试一次即可，但是有些bug可能比较隐性，比如执行了写入但没有暴露出来，这个就需要有相应的匹配操作来进行检验

### 检验数据通路







### 检验控制信号









