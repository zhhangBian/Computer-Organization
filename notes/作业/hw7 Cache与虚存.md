**卞卓航 22373017**

## 第一题

平均时t=10ns+(1-0.9)*60ns=16ns

## 第二题

### 1

对于该Cache，一块内有16字节，故需要最低4位作为块内字节索引

数据存储空间共64KB，Cache一组的容量位4*16=64B，故需要1K组，需要10位作为组索引

则余下的32-10-4=18作为tag，用于核对块内数据是否命中

故主存地址格式为：18位tag+10位组索引+4位块内字节索引

### 2

对于Cache中的每一块，需要一个标记位，用于判断该块是否有效

其次，每块16字节，4个字，按照题目要求，需要4个脏位用于判断是否被修改

每块还本身有18位的tag用于判断是否命中

故总容量C=组数\*每组的块数\*每块的位数=1K\*4\*(1+4+18+16*8)=604Kbit=75.7Kbyte

## 第三题

该Cache是一个4路组相联Cache，总共4K字；每块64个字，256字节，块内字节索引需要8位；每组4块，256字，故需要16组

主存和Cache均按照每块64个字进行很快，在按照组相联的方式进行存取

可以画出如下表格：m为整数

| 组数 | 对应块范围 |
| ---- | ---------- |
| 0    | 16m+0      |
| 1    | 16m+1      |
| 2    | 16m+2      |
| 3    | 16m+3      |
| 4    | 16m+4      |
| 5    | 16m+5      |
| 6    | 16m+6      |
| 7    | 16m+7      |
| 8    | 16m+8      |
| 9    | 16m+9      |
| 10   | 16m+10     |
| 11   | 16m+11     |
| 12   | 16m+12     |
| 13   | 16m+13     |
| 14   | 16m+14     |
| 15   | 16m+15     |

由于每块64个字，4351=66*64+27，故4351处在第67块中

在第一次循环时，对于主存中的1\~63块，也即1\~4095字，当进行读取时，Cache中没有对应的tag，且相应的组中还有空位，都发生缺失。第64\~67块进行读入时，由LRU替换算法替换第0、1、2、3块

在之后的循环中，由于LRU算法，第0、1、2、3块平凡发生因缺失导致的替换，第4~15块不发生替换，始终命中

### 1

对于命中率，总共取字4351*10=43510次

对于缺失次数：

1. 在第一轮循环时，取64m+0…15字时发生缺失，即64个块第一次取时总缺失；且取64、65、66、67块的第一个字取时也缺失，故总共缺失68次。

2. 在之后的循环中，每一轮循环的第0、1、2、3组总是发生5次缺失，其他不发生缺失，故缺失4\*5\*9=180次缺失

   以第0组为例，在第二轮循环时

   | 当前取的字 | 块1    | 块2   | 块3    | 块4    |
   | ---------- | ------ | ----- | ------ | ------ |
   | 0          | 64     | 16->0 | 32     | 48     |
   | 16         | 64     | 0     | 32->16 | 48     |
   | 32         | 64     | 0     | 16     | 48->32 |
   | 48         | 64->48 | 0     | 16     | 32     |
   | 64         | 48     | 0->64 | 16     | 32     |

   共发生5次缺失

故缺失率=（68+180）/43510=0.57%

命中率=1-（68+180）/43510=99.43%

### 2

假设访问Cache的时间为T，则命中的话所花费时间为T，若缺失所花费时间为11T，若不采用Cache，访问一次花费10T

采用Cache后花费的时间t1=(43150-248)\*T+248\*11T=45630T

不采用Cache花费的时间t2=43150\*10T=431500T

加速比=t2/t1=9.46

## 第四题

### 1

该Cache每块共64/4=16字

出现一次缺失的存取时间t1=2.5ns+50ns+15*5ns=127.5ns

### 2

原先的平均存取时间T1=0.95\*2.5ns+0.05\*127.5ns=8.75ns

现在Cache每块共128/4=32字，出现一次缺失的存取时间为t2=2.5ns+50ns+31*5ns=207.5ns

现在的平均存取时间T1=0.97\*2.5ns+0.03\*207.5ns=8.65ns

降低了平均存取时间

## 第五题

由虚存性质，VPO位数=PPO位数恒成立

| P    | VPN位数 | VPO位数 | PPN位数 | PPO位数 |
| ---- | ------- | ------- | ------- | ------- |
| 1KB  | 22      | 10      | 14      | 10      |
| 2KB  | 21      | 11      | 13      | 11      |
| 4KB  | 20      | 12      | 12      | 12      |
| 8KB  | 19      | 13      | 11      | 13      |

## 第六题

### 1

对于该虚存，页大小128字节，故业内偏移量为7位，为地址的低7位。

对于虚拟地址，高9位（16\~7位）表示虚拟页号；最低7位（6\~0位）表示页内偏移量。

TLB为4路组相联需要组索引2位（1\~0位）；虚拟页号共9位，虚拟页号的高7位（9\~2位）为TLB标记

### 2

对于物理地址，高5位（12\~7位）为物理页号，低7位（6\~0位）位页内偏移量

对于该直相连Cache，每块4字节，故需要2位的块内字节索引；共16行，需要4位的行索引，其余为标记位，共12-2-4=6位

地址表示为：标记位（6位）-行索引（4位）-块内字节索引（2位）

### 3

当CPU想要取0x067A地址处的数据时：

1. 先访问TLB，0x067A的业内偏移量位0x111_1010，虚拟页号为0xC，访问TLB第0组，标记位为0x3，缺失
2. 由于TLB缺失，访问页表0xC，有效位为1，得到实页号为0x19，拼接得到物理地址0b1100_1111_1010
3. 利用该地址，先访问Cache，利用5\~2位得到行索引0b1110=0xE，标记位为0b11_0011=0x33，命中
4. 最后，根据地址低2位的块内字节索引，得到数据0x4A

得到数据0x4A

## 第七题

### 1

该Cache为8路组相联，每块存256字节，故Cache组数为32K/(256\*8)=16

### 2

主存也按照每块256字节进行分块，每组有32Mbyte/(16\*256byte)=8192块

### 3

对于每块，有256字节，故块内字节索引需要8位；共16组，故组索引需要4位，其余均为tag位；对于主存，地址共log(2M)=21位，故剩余21-8-4=9位的tag位

主存的地址分为3部分，为：tag位（9位）-组索引（4位）-块内字节索引（8位）

### 4

对于Cache的tag，其位数为：有效位（1为）-可能的脏位（本题为要求）-地址tag位（9位）

### 5

该现象是常见的，由于采用组相联方式，可能出现一组未满，一组已满，体现在整个Cache上是未满的，当新块是在满的组时，需要进行替换才能调入

如一个2路组相联Cache，假设此时Cache存储的数据tag的情况为：

| 组数 | 块1数据的地址 | 块2数据的地址 |
| ---- | ------------- | ------------- |
| 1    | 1             | 3             |
| 2    | 2             | 空            |

当新的一个块，如地址为5被请求时，分组至第一组，但第一组已满，需要替换才能调入时